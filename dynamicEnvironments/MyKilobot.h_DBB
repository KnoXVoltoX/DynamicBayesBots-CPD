/*
Approach of adaptive Bayes Bots by Kai Pfister 
*/

#include <kilosim/Kilobot.h>

#include <boost/math/distributions/beta.hpp>
#include <boost/math/special_functions/beta.hpp>
#include <boost/math/distributions/exponential.hpp>
#include <iostream>
#include <vector>
#include <random>


namespace Kilosim
{

class MyKilobot : public Kilobot
{
  public:
    // These parameters are accessible from the main.cpp
    int16_t light_intensity = -1;
    bool observe = false;
    int id = 0;                       // ID of the robot
    bool uPos = true;                 // Postive feedback (atm always true)
    float pc = 0.0;                   // Credible threshold (min. propab. mass)
    float pres = 0.0;                 // Reset threshold
    float plim = 0.0;                 // Sample limit
    float log_q = 0.0;
    int log_df = 0;
    int log_res = 0;
    float check = 1.0;                // Debug/ Monitoring variable


  private:
    #define STOP 0
    #define FORWARD 1
    #define LEFT 2
    #define RIGHT 3

    // Initialize
    message_t transmit_msg;
    bool new_message = 0;
    uint32_t last_checked = 0;
    int random_number = 0;
    int rw = 0;                       // Random walk (1: straigth segment, 0: turn)
    int curr_motion = 0;              // Current motion of the random walk
    uint32_t next_check_dur;
    double alpha0 = 10.0;             // Prior parameter (initialization of beta distribution)
    double alpha;
    double beta;
    float q = 0.5;                    // Beta CDF
    int16_t C;                        // Color observation
    uint32_t i = 0;                   // Observation index
    int m[9];                         // Message array
    std::vector<int> s;               // Dictionary of received observations
    int df = -1;                      // Decision
    int dReset = 0;                   // Reset flag
    int countR = 0;                   // Counter of resets
    double lambda = 1/(240*SECOND);   // SECOND to get kiloticks per second
    int turn_max = 12*SECOND;         // 12 --> 2*PI/0.5 for a whole turn with a turnspeed of 0.5rad/s
    int lock_dict = 0;

    void set_motion(int new_motion)
    {
        if (curr_motion != new_motion)
        {
            curr_motion = new_motion;
            if (new_motion == STOP)
            {
                set_motors(0, 0);
            }
            else if (new_motion == FORWARD)
            {
                spinup_motors();
                set_motors(kilo_straight_left, kilo_straight_right);
            }
            else if (new_motion == LEFT)
            {
                spinup_motors();
                set_motors(kilo_turn_left, 0);
            }
            else
            { // RIGHT
                spinup_motors();
                set_motors(0, kilo_turn_right);
            }
        }
    }


    /*
    Function proofs if environment has changed.
    The robot checks if its belive q falls below the threshold the pres after its previous decision (credible threshold was reached).
    If so reset.
    */
    void decision_Reset(int decision, double betaCDF)
    {
        if (decision > 0)
        {
            if ((1-betaCDF)<pres)
            {
                df = -1;
                dReset = 1;
                countR += 1;
            }
        }
        else if (decision == 0)
        {
            if (betaCDF<pres)
            {
                df = -1;
                dReset = 1;
                countR += 1;
            }
        }
    }


    // Reset of all parameters after a reset flag was set
    void reset()
    {
        dReset = 0;                       // Reset reset flag
        s.clear();                        // Clear the dictionary
        m[3] = 5;
        m[4] = 0;
        transmit_msg.data[3] = 5;
        transmit_msg.data[4] = 0;
        df = -1;
        alpha = alpha0;
        beta = alpha0;
        i = 0;
        set_color(RGB(0, 0, 1));
    }


    void setup()
    {
        transmit_msg.type = NORMAL;
        transmit_msg.data[0] = 0;
        transmit_msg.data[3] = 5;
        transmit_msg.crc = message_crc(&transmit_msg);
        set_color(RGB(0, 0, 1));
        set_motion(FORWARD);
        next_check_dur = 0;
        i = 0;
        m[4] = 0;
        m[3] = 5;
        alpha = alpha0;
        beta = alpha0;
        countR = 0;
        rw = 1;
    }


    void loop()
    {
        //check = q;                          // Debug variable
        log_q=q;
        log_df=df;
        log_res=countR;
        light_intensity = get_ambientlight();

        // random walk
        if ((kilo_ticks > last_checked + next_check_dur)||((light_intensity < 700) && (light_intensity > 300)))
        {
            std::random_device rd;
            std::mt19937 gen(rd());
            std::exponential_distribution<> exp_dist(lambda); // Draw from an exponential distribution
            std::uniform_real_distribution<> uni_dist(0, 1);  // Draw from an uniform distribution
            double straigth_dur = exp_dist(gen);
            double turn_dur = (uni_dist(gen)*turn_max);	//robot turn speed 0.5 rad/s
            next_check_dur = 0;
            last_checked = kilo_ticks;

            // Turn to navigate out of the border (gray area)
            if ((light_intensity < 700) && (light_intensity > 300))
            {
                set_motion(RIGHT);
            }
            else if (rw == 1)
            {
                next_check_dur = int(-log((double)rand_hard() / 255.0) * (240*SECOND));
                set_motion(FORWARD);
                rw = 0;
            }
            else if(rw == 0)
            {
                if(uni_dist(gen))
                {
                  next_check_dur = turn_dur;
                  set_motion(RIGHT);
                }
                else
                {
                  next_check_dur = turn_dur;
                  set_motion(LEFT);
                }
                rw = 1;
            }
        }


        // Dictionary at the moment not in use. Idea: weight trustworthy Robots heigher?
        lock_dict = 1;
        if (new_message)
        {
            for (long unsigned int j=0; j<s.size();j++)
            {
            }
            new_message = 0;
        }
        lock_dict = 0;


        // Check for reset
        if (((m[3]==0)&&(m[3]!=df)&&(m[5]>countR)&&(q>pres))||((m[3]==1)&&(m[3]!=df)&&(m[5]>countR)&&((1-q)>pres)))
        {
            dReset = 1;
            countR += 1;
        }

        if (dReset != 0)
        {
            reset();
        }


        // Strong positive Feedback
        if ((5!=m[3])&&(df==5)&&(countR<=m[5]))
        {
            df = m[3];
            alpha = m[6];
            beta = m[7];

            if (df > 0)
            {
                set_color(RGB(0, 1, 0));
            }
            else
            {
                set_color(RGB(1, 0, 0));
            }
        }
        else if ((5!=m[3])&&(df==m[3])&&(countR<m[5]))
        {
            if ((m[3]>0)&&(q>(1-plim))){
                alpha += 1;
            }
            else if(q<plim)
            {
                beta += 1;
            }
        }

        // Observation of tile below
        if ((observe == true) && ((light_intensity > 700) || (light_intensity < 300)))
        {
            observe = false;
            light_intensity = get_ambientlight();

            if (light_intensity > 700)
            {
                C = 1;
            }
            else
            {
                C = 0;
            }
            if((q>(1-plim)))
            {
                alpha += C;
                i ++;
            }
            if((q<plim))
            {
                beta += (1-C);
            }


            // Calculate the CDF
            q = boost::math::ibeta((double)alpha, (double)beta, (double)0.5);
            if (q>plim){
                q = plim;
            }
            else if (q<(1-plim)){
                q = 1-plim;
            }

            // Decision making
            if (df == -1){
                set_color(RGB(q, (1-q), 1));

                if (q > pc)
                {
                    df = 0;
                    set_color(RGB(1, 0, 0));
                }
                else if ((1-q) > pc)
                {
                    df = 1;
                    set_color(RGB(0, 1, 0));
                }
            }

            // Check if a reset is needed (environment change)
            decision_Reset(df, q);
        }
    }


    // Prepare the message content
    void update_transmit_msg()
    {
        transmit_msg.type = NORMAL;
        transmit_msg.data[0] = id;
        transmit_msg.data[1] = i;
        transmit_msg.data[3] = df;
        transmit_msg.data[4] = dReset;
        transmit_msg.data[5] = countR;
        transmit_msg.data[6] = alpha;
        transmit_msg.data[7] = beta;

        if (df != -1 && uPos)
            transmit_msg.data[2] = df;
        else
            transmit_msg.data[2] = C;

        transmit_msg.crc = message_crc(&transmit_msg);
    }


    // Receiving message
    void message_rx(message_t *msg, distance_measurement_t *dist)
    {
        if ((comm_criteria(*dist) == true) && (lock_dict==0))
        {
            m[0] = msg->data[0];    // robot id
            m[1] = msg->data[1];    // number of color observation
            m[2] = msg->data[2];    // color observation
            m[3] = msg->data[3];    // decision message
            m[4] = msg->data[4];    // reset message
            m[5] = msg->data[5];    // reset counter
            m[6] = msg->data[6];    // alpha
            m[7] = msg->data[7];    // beta

            new_message = 1;        // Set the flag to 1 to indicate a new message received
        }
    }

    // Sending message
    message_t *message_tx()
    {
        update_transmit_msg();
        return &transmit_msg;
    }

    void message_tx_success() {}
};
} // namespace Kilosim
